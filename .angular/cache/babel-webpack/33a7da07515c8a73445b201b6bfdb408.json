{"ast":null,"code":"import { ComponentRef, ElementRef, EventEmitter, Renderer2, SimpleChanges, ViewContainerRef } from '@angular/core';\nimport { ComponentLoaderFactory } from 'ngx-bootstrap/component-loader';\nimport { BehaviorSubject, Subject } from 'rxjs';\nimport { filter, takeUntil } from 'rxjs/operators';\nimport { BsDatepickerConfig } from './bs-datepicker.config';\nimport { BsDatepickerContainerComponent } from './themes/bs/bs-datepicker-container.component';\nimport { copyTime } from './utils/copy-time-utils';\nimport { checkBsValue, setCurrentTimeOnDateSelect } from './utils/bs-calendar-utils';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./bs-datepicker.config\";\nimport * as i2 from \"ngx-bootstrap/component-loader\";\nexport let BsDatepickerDirective = /*#__PURE__*/(() => {\n  class BsDatepickerDirective {\n    constructor(_config, _elementRef, _renderer, _viewContainerRef, cis) {\n      this._config = _config;\n      this._elementRef = _elementRef;\n      this._renderer = _renderer;\n      /**\r\n       * Placement of a datepicker. Accepts: \"top\", \"bottom\", \"left\", \"right\"\r\n       */\n\n      this.placement = 'bottom';\n      /**\r\n       * Specifies events that should trigger. Supports a space separated list of\r\n       * event names.\r\n       */\n\n      this.triggers = 'click';\n      /**\r\n       * Close datepicker on outside click\r\n       */\n\n      this.outsideClick = true;\n      /**\r\n       * A selector specifying the element the datepicker should be appended to.\r\n       */\n\n      this.container = 'body';\n      this.outsideEsc = true;\n      this.isDestroy$ = new Subject();\n      /**\r\n       * Indicates whether datepicker's content is enabled or not\r\n       */\n\n      this.isDisabled = false;\n      /**\r\n       * Emits when datepicker value has been changed\r\n       */\n\n      this.bsValueChange = new EventEmitter();\n      this._subs = [];\n      this._dateInputFormat$ = new Subject(); // todo: assign only subset of fields\n\n      Object.assign(this, this._config);\n      this._datepicker = cis.createLoader(_elementRef, _viewContainerRef, _renderer);\n      this.onShown = this._datepicker.onShown;\n      this.onHidden = this._datepicker.onHidden;\n      this.isOpen$ = new BehaviorSubject(this.isOpen);\n    }\n    /**\r\n     * Returns whether or not the datepicker is currently being shown\r\n     */\n\n\n    get isOpen() {\n      return this._datepicker.isShown;\n    }\n\n    set isOpen(value) {\n      this.isOpen$.next(value);\n    }\n    /**\r\n     * Initial value of datepicker\r\n     */\n\n\n    set bsValue(value) {\n      var _a;\n\n      if (this._bsValue && value && this._bsValue.getTime() === value.getTime()) {\n        return;\n      }\n\n      if (!this._bsValue && value && !this._config.withTimepicker) {\n        const now = new Date();\n        copyTime(value, now);\n      }\n\n      if (value && ((_a = this.bsConfig) === null || _a === void 0 ? void 0 : _a.initCurrentTime)) {\n        value = setCurrentTimeOnDateSelect(value);\n      }\n\n      this._bsValue = value;\n      this.bsValueChange.emit(value);\n    }\n\n    get dateInputFormat$() {\n      return this._dateInputFormat$;\n    }\n\n    ngOnInit() {\n      this._datepicker.listen({\n        outsideClick: this.outsideClick,\n        outsideEsc: this.outsideEsc,\n        triggers: this.triggers,\n        show: () => this.show()\n      });\n\n      this.setConfig();\n    }\n\n    ngOnChanges(changes) {\n      var _a, _b, _c, _d;\n\n      if (changes[\"bsConfig\"]) {\n        if (((_a = changes[\"bsConfig\"].currentValue) === null || _a === void 0 ? void 0 : _a.initCurrentTime) && ((_b = changes[\"bsConfig\"].currentValue) === null || _b === void 0 ? void 0 : _b.initCurrentTime) !== ((_c = changes[\"bsConfig\"].previousValue) === null || _c === void 0 ? void 0 : _c.initCurrentTime) && this._bsValue) {\n          this._bsValue = setCurrentTimeOnDateSelect(this._bsValue);\n          this.bsValueChange.emit(this._bsValue);\n        }\n\n        this.setConfig();\n\n        this._dateInputFormat$.next(this.bsConfig && this.bsConfig.dateInputFormat);\n      }\n\n      if (!this._datepickerRef || !this._datepickerRef.instance) {\n        return;\n      }\n\n      if (changes[\"minDate\"]) {\n        this._datepickerRef.instance.minDate = this.minDate;\n      }\n\n      if (changes[\"maxDate\"]) {\n        this._datepickerRef.instance.maxDate = this.maxDate;\n      }\n\n      if (changes[\"daysDisabled\"]) {\n        this._datepickerRef.instance.daysDisabled = this.daysDisabled;\n      }\n\n      if (changes[\"datesDisabled\"]) {\n        this._datepickerRef.instance.datesDisabled = this.datesDisabled;\n      }\n\n      if (changes[\"datesEnabled\"]) {\n        this._datepickerRef.instance.datesEnabled = this.datesEnabled;\n      }\n\n      if (changes[\"isDisabled\"]) {\n        if ((_d = this._elementRef) === null || _d === void 0 ? void 0 : _d.nativeElement) {\n          this._elementRef.nativeElement.setAttribute('readonly', this.isDisabled);\n        }\n\n        this._datepickerRef.instance.isDisabled = this.isDisabled;\n      }\n\n      if (changes[\"dateCustomClasses\"]) {\n        this._datepickerRef.instance.dateCustomClasses = this.dateCustomClasses;\n      }\n\n      if (changes[\"dateTooltipTexts\"]) {\n        this._datepickerRef.instance.dateTooltipTexts = this.dateTooltipTexts;\n      }\n    }\n\n    ngAfterViewInit() {\n      this.isOpen$.pipe(filter(isOpen => isOpen !== this.isOpen), takeUntil(this.isDestroy$)).subscribe(() => this.toggle());\n    }\n    /**\r\n     * Opens an element’s datepicker. This is considered a “manual” triggering of\r\n     * the datepicker.\r\n     */\n\n\n    show() {\n      if (this._datepicker.isShown) {\n        return;\n      }\n\n      this.setConfig();\n      this._datepickerRef = this._datepicker.provide({\n        provide: BsDatepickerConfig,\n        useValue: this._config\n      }).attach(BsDatepickerContainerComponent).to(this.container).position({\n        attachment: this.placement\n      }).show({\n        placement: this.placement\n      }); // if date changes from external source (model -> view)\n\n      this._subs.push(this.bsValueChange.subscribe(value => {\n        if (this._datepickerRef) {\n          this._datepickerRef.instance.value = value;\n        }\n      })); // if date changes from picker (view -> model)\n\n\n      if (this._datepickerRef) {\n        this._subs.push(this._datepickerRef.instance.valueChange.subscribe(value => {\n          this.bsValue = value;\n          this.hide();\n        }));\n      }\n    }\n    /**\r\n     * Closes an element’s datepicker. This is considered a “manual” triggering of\r\n     * the datepicker.\r\n     */\n\n\n    hide() {\n      if (this.isOpen) {\n        this._datepicker.hide();\n      }\n\n      for (const sub of this._subs) {\n        sub.unsubscribe();\n      }\n\n      if (this._config.returnFocusToInput) {\n        this._renderer.selectRootElement(this._elementRef.nativeElement).focus();\n      }\n    }\n    /**\r\n     * Toggles an element’s datepicker. This is considered a “manual” triggering\r\n     * of the datepicker.\r\n     */\n\n\n    toggle() {\n      if (this.isOpen) {\n        return this.hide();\n      }\n\n      this.show();\n    }\n    /**\r\n     * Set config for datepicker\r\n     */\n\n\n    setConfig() {\n      var _a;\n\n      this._config = Object.assign({}, this._config, this.bsConfig, {\n        value: checkBsValue(this._bsValue, this.maxDate || this.bsConfig && this.bsConfig.maxDate),\n        isDisabled: this.isDisabled,\n        minDate: this.minDate || this.bsConfig && this.bsConfig.minDate,\n        maxDate: this.maxDate || this.bsConfig && this.bsConfig.maxDate,\n        daysDisabled: this.daysDisabled || this.bsConfig && this.bsConfig.daysDisabled,\n        dateCustomClasses: this.dateCustomClasses || this.bsConfig && this.bsConfig.dateCustomClasses,\n        dateTooltipTexts: this.dateTooltipTexts || this.bsConfig && this.bsConfig.dateTooltipTexts,\n        datesDisabled: this.datesDisabled || this.bsConfig && this.bsConfig.datesDisabled,\n        datesEnabled: this.datesEnabled || this.bsConfig && this.bsConfig.datesEnabled,\n        minMode: this.minMode || this.bsConfig && this.bsConfig.minMode,\n        initCurrentTime: (_a = this.bsConfig) === null || _a === void 0 ? void 0 : _a.initCurrentTime\n      });\n    }\n\n    ngOnDestroy() {\n      this._datepicker.dispose();\n\n      this.isOpen$.next(false);\n\n      if (this.isDestroy$) {\n        this.isDestroy$.next(null);\n        this.isDestroy$.complete();\n      }\n    }\n\n  }\n\n  BsDatepickerDirective.ɵfac = function BsDatepickerDirective_Factory(t) {\n    return new (t || BsDatepickerDirective)(i0.ɵɵdirectiveInject(i1.BsDatepickerConfig), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i2.ComponentLoaderFactory));\n  };\n\n  BsDatepickerDirective.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: BsDatepickerDirective,\n    selectors: [[\"\", \"bsDatepicker\", \"\"]],\n    inputs: {\n      placement: \"placement\",\n      triggers: \"triggers\",\n      outsideClick: \"outsideClick\",\n      container: \"container\",\n      outsideEsc: \"outsideEsc\",\n      isDisabled: \"isDisabled\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\",\n      minMode: \"minMode\",\n      daysDisabled: \"daysDisabled\",\n      datesDisabled: \"datesDisabled\",\n      datesEnabled: \"datesEnabled\",\n      dateCustomClasses: \"dateCustomClasses\",\n      dateTooltipTexts: \"dateTooltipTexts\",\n      isOpen: \"isOpen\",\n      bsValue: \"bsValue\",\n      bsConfig: \"bsConfig\"\n    },\n    outputs: {\n      onShown: \"onShown\",\n      onHidden: \"onHidden\",\n      bsValueChange: \"bsValueChange\"\n    },\n    exportAs: [\"bsDatepicker\"],\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return BsDatepickerDirective;\n})();","map":null,"metadata":{},"sourceType":"module"}