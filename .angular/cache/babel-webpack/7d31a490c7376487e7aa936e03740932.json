{"ast":null,"code":"import { EventEmitter, SimpleChanges } from '@angular/core';\nimport { DateFormatter } from './date-formatter';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\n\nfunction DatePickerInnerComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 1);\n    i0.ɵɵprojection(1);\n    i0.ɵɵelementEnd();\n  }\n}\n\nconst _c0 = [\"*\"];\nexport let DatePickerInnerComponent = /*#__PURE__*/(() => {\n  class DatePickerInnerComponent {\n    constructor() {\n      this.monthColLimit = 0;\n      this.yearColLimit = 0;\n      this.selectionDone = new EventEmitter(undefined);\n      this.update = new EventEmitter(false);\n      this.activeDateChange = new EventEmitter(undefined);\n      this.stepDay = {};\n      this.stepMonth = {};\n      this.stepYear = {};\n      this.modes = ['day', 'month', 'year'];\n      this.dateFormatter = new DateFormatter();\n    }\n\n    get activeDate() {\n      return this._activeDate;\n    }\n\n    set activeDate(value) {\n      this._activeDate = value;\n    } // todo: add formatter value to Date object\n\n\n    ngOnInit() {\n      // todo: use date for unique value\n      this.uniqueId = `datepicker--${Math.floor(Math.random() * 10000)}`;\n\n      if (this.initDate) {\n        this.activeDate = this.initDate;\n        this.selectedDate = new Date(this.activeDate.valueOf());\n        this.update.emit(this.activeDate);\n      } else if (this.activeDate === undefined) {\n        this.activeDate = new Date();\n      }\n    } // this.refreshView should be called here to reflect the changes on the fly\n\n\n    ngOnChanges(changes) {\n      this.refreshView();\n      this.checkIfActiveDateGotUpdated(changes[\"activeDate\"]);\n    } // Check if activeDate has been update and then emit the activeDateChange with the new date\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    checkIfActiveDateGotUpdated(activeDate) {\n      if (activeDate && !activeDate.firstChange) {\n        const previousValue = activeDate.previousValue;\n\n        if (previousValue && previousValue instanceof Date && previousValue.getTime() !== activeDate.currentValue.getTime()) {\n          this.activeDateChange.emit(this.activeDate);\n        }\n      }\n    }\n\n    setCompareHandler(handler, type) {\n      if (type === 'day') {\n        this.compareHandlerDay = handler;\n      }\n\n      if (type === 'month') {\n        this.compareHandlerMonth = handler;\n      }\n\n      if (type === 'year') {\n        this.compareHandlerYear = handler;\n      }\n    }\n\n    compare(date1, date2) {\n      if (date1 === undefined || date2 === undefined) {\n        return undefined;\n      }\n\n      if (this.datepickerMode === 'day' && this.compareHandlerDay) {\n        return this.compareHandlerDay(date1, date2);\n      }\n\n      if (this.datepickerMode === 'month' && this.compareHandlerMonth) {\n        return this.compareHandlerMonth(date1, date2);\n      }\n\n      if (this.datepickerMode === 'year' && this.compareHandlerYear) {\n        return this.compareHandlerYear(date1, date2);\n      }\n\n      return void 0;\n    }\n\n    setRefreshViewHandler(handler, type) {\n      if (type === 'day') {\n        this.refreshViewHandlerDay = handler;\n      }\n\n      if (type === 'month') {\n        this.refreshViewHandlerMonth = handler;\n      }\n\n      if (type === 'year') {\n        this.refreshViewHandlerYear = handler;\n      }\n    }\n\n    refreshView() {\n      if (this.datepickerMode === 'day' && this.refreshViewHandlerDay) {\n        this.refreshViewHandlerDay();\n      }\n\n      if (this.datepickerMode === 'month' && this.refreshViewHandlerMonth) {\n        this.refreshViewHandlerMonth();\n      }\n\n      if (this.datepickerMode === 'year' && this.refreshViewHandlerYear) {\n        this.refreshViewHandlerYear();\n      }\n    }\n\n    dateFilter(date, format) {\n      return this.dateFormatter.format(date, format, this.locale);\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    isActive(dateObject) {\n      if (this.compare(dateObject.date, this.activeDate) === 0) {\n        this.activeDateId = dateObject.uid;\n        return true;\n      }\n\n      return false;\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    createDateObject(date, format) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const dateObject = {};\n      dateObject.date = new Date(date.getFullYear(), date.getMonth(), date.getDate());\n      dateObject.date = this.fixTimeZone(dateObject.date);\n      dateObject.label = this.dateFilter(date, format);\n      dateObject.selected = this.compare(date, this.selectedDate) === 0;\n      dateObject.disabled = this.isDisabled(date);\n      dateObject.current = this.compare(date, new Date()) === 0;\n      dateObject.customClass = this.getCustomClassForDate(dateObject.date);\n      return dateObject;\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    split(arr, size) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const arrays = [];\n\n      while (arr.length > 0) {\n        arrays.push(arr.splice(0, size));\n      }\n\n      return arrays;\n    } // Fix a hard-reproducible bug with timezones\n    // The bug depends on OS, browser, current timezone and current date\n    // i.e.\n    // var date = new Date(2014, 0, 1);\n    // console.log(date.getFullYear(), date.getMonth(), date.getDate(),\n    // date.getHours()); can result in \"2013 11 31 23\" because of the bug.\n\n\n    fixTimeZone(date) {\n      const hours = date.getHours();\n      return new Date(date.getFullYear(), date.getMonth(), date.getDate(), hours === 23 ? hours + 2 : 0);\n    }\n\n    select(date, isManual = true) {\n      if (this.datepickerMode === this.minMode) {\n        if (!this.activeDate) {\n          this.activeDate = new Date(0, 0, 0, 0, 0, 0, 0);\n        }\n\n        this.activeDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());\n        this.activeDate = this.fixTimeZone(this.activeDate);\n\n        if (isManual) {\n          this.selectionDone.emit(this.activeDate);\n        }\n      } else {\n        this.activeDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());\n        this.activeDate = this.fixTimeZone(this.activeDate);\n\n        if (isManual && this.datepickerMode) {\n          this.datepickerMode = this.modes[this.modes.indexOf(this.datepickerMode) - 1];\n        }\n      }\n\n      this.selectedDate = new Date(this.activeDate.valueOf());\n      this.update.emit(this.activeDate);\n      this.refreshView();\n    }\n\n    move(direction) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let expectedStep;\n\n      if (this.datepickerMode === 'day') {\n        expectedStep = this.stepDay;\n      }\n\n      if (this.datepickerMode === 'month') {\n        expectedStep = this.stepMonth;\n      }\n\n      if (this.datepickerMode === 'year') {\n        expectedStep = this.stepYear;\n      }\n\n      if (expectedStep && this.activeDate) {\n        const year = this.activeDate.getFullYear() + direction * (expectedStep.years || 0);\n        const month = this.activeDate.getMonth() + direction * (expectedStep.months || 0);\n        this.activeDate = new Date(year, month, 1);\n        this.refreshView();\n        this.activeDateChange.emit(this.activeDate);\n      }\n    }\n\n    toggleMode(_direction) {\n      const direction = _direction || 1;\n\n      if (this.datepickerMode === this.maxMode && direction === 1 || this.datepickerMode === this.minMode && direction === -1) {\n        return;\n      }\n\n      if (this.datepickerMode) {\n        this.datepickerMode = this.modes[this.modes.indexOf(this.datepickerMode) + direction];\n      }\n\n      this.refreshView();\n    }\n\n    getCustomClassForDate(date) {\n      if (!this.customClass) {\n        return '';\n      } // todo: build a hash of custom classes, it will work faster\n\n\n      const customClassObject = this.customClass.find(customClass => {\n        return customClass.date.valueOf() === date.valueOf() && customClass.mode === this.datepickerMode;\n      }, this);\n      return customClassObject === undefined ? '' : customClassObject.clazz;\n    }\n\n    compareDateDisabled(date1Disabled, date2) {\n      if (date1Disabled === undefined || date2 === undefined) {\n        return undefined;\n      }\n\n      if (date1Disabled.mode === 'day' && this.compareHandlerDay) {\n        return this.compareHandlerDay(date1Disabled.date, date2);\n      }\n\n      if (date1Disabled.mode === 'month' && this.compareHandlerMonth) {\n        return this.compareHandlerMonth(date1Disabled.date, date2);\n      }\n\n      if (date1Disabled.mode === 'year' && this.compareHandlerYear) {\n        return this.compareHandlerYear(date1Disabled.date, date2);\n      }\n\n      return undefined;\n    }\n\n    isDisabled(date) {\n      let isDateDisabled = false;\n\n      if (this.dateDisabled) {\n        this.dateDisabled.forEach(disabledDate => {\n          if (this.compareDateDisabled(disabledDate, date) === 0) {\n            isDateDisabled = true;\n          }\n        });\n      }\n\n      if (this.dayDisabled) {\n        isDateDisabled = isDateDisabled || this.dayDisabled.indexOf(date.getDay()) > -1;\n      }\n\n      if (isDateDisabled) {\n        return isDateDisabled;\n      }\n\n      const minDate = Number(this.minDate && this.compare(date, this.minDate));\n\n      if (!isNaN(minDate)) {\n        return minDate < 0;\n      }\n\n      const maxDate = Number(this.maxDate && this.compare(date, this.maxDate));\n\n      if (!isNaN(maxDate)) {\n        return maxDate > 0;\n      }\n\n      return false;\n    }\n\n  }\n\n  DatePickerInnerComponent.ɵfac = function DatePickerInnerComponent_Factory(t) {\n    return new (t || DatePickerInnerComponent)();\n  };\n\n  DatePickerInnerComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: DatePickerInnerComponent,\n    selectors: [[\"datepicker-inner\"]],\n    inputs: {\n      locale: \"locale\",\n      datepickerMode: \"datepickerMode\",\n      startingDay: \"startingDay\",\n      yearRange: \"yearRange\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\",\n      minMode: \"minMode\",\n      maxMode: \"maxMode\",\n      showWeeks: \"showWeeks\",\n      formatDay: \"formatDay\",\n      formatMonth: \"formatMonth\",\n      formatYear: \"formatYear\",\n      formatDayHeader: \"formatDayHeader\",\n      formatDayTitle: \"formatDayTitle\",\n      formatMonthTitle: \"formatMonthTitle\",\n      onlyCurrentMonth: \"onlyCurrentMonth\",\n      shortcutPropagation: \"shortcutPropagation\",\n      customClass: \"customClass\",\n      monthColLimit: \"monthColLimit\",\n      yearColLimit: \"yearColLimit\",\n      dateDisabled: \"dateDisabled\",\n      dayDisabled: \"dayDisabled\",\n      initDate: \"initDate\",\n      activeDate: \"activeDate\"\n    },\n    outputs: {\n      selectionDone: \"selectionDone\",\n      update: \"update\",\n      activeDateChange: \"activeDateChange\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 1,\n    consts: [[\"class\", \"well well-sm bg-faded p-a card\", \"role\", \"application\", 4, \"ngIf\"], [\"role\", \"application\", 1, \"well\", \"well-sm\", \"bg-faded\", \"p-a\", \"card\"]],\n    template: function DatePickerInnerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, DatePickerInnerComponent_div_0_Template, 2, 0, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.datepickerMode);\n      }\n    },\n    directives: [i1.NgIf],\n    encapsulation: 2\n  });\n  return DatePickerInnerComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}