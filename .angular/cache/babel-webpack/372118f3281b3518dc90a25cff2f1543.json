{"ast":null,"code":"// todo: should we support enforce focus in?\n// todo: in original bs there are was a way to prevent modal from showing\n// todo: original modal had resize events\nimport { ComponentRef, ElementRef, EventEmitter, Renderer2, ViewContainerRef } from '@angular/core';\nimport { document, window, isBs3, Utils } from 'ngx-bootstrap/utils';\nimport { ModalBackdropComponent } from './modal-backdrop.component';\nimport { CLASS_NAME, DISMISS_REASONS, modalConfigDefaults, ModalOptions, MODAL_CONFIG_DEFAULT_OVERRIDE } from './modal-options.class';\nimport { ComponentLoaderFactory } from 'ngx-bootstrap/component-loader';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"ngx-bootstrap/component-loader\";\nimport * as i2 from \"./modal-options.class\";\nconst TRANSITION_DURATION = 300;\nconst BACKDROP_TRANSITION_DURATION = 150;\n/** Mark any code with directive to show it's content in modal */\n\nexport let ModalDirective = /*#__PURE__*/(() => {\n  class ModalDirective {\n    constructor(_element, _viewContainerRef, _renderer, clf, modalDefaultOption) {\n      this._element = _element;\n      this._renderer = _renderer;\n      /** This event fires immediately when the `show` instance method is called. */\n\n      this.onShow = new EventEmitter();\n      /** This event is fired when the modal has been made visible to the user\r\n       * (will wait for CSS transitions to complete)\r\n       */\n\n      this.onShown = new EventEmitter();\n      /** This event is fired immediately when\r\n       * the hide instance method has been called.\r\n       */\n\n      this.onHide = new EventEmitter();\n      /** This event is fired when the modal has finished being\r\n       * hidden from the user (will wait for CSS transitions to complete).\r\n       */\n\n      this.onHidden = new EventEmitter();\n      this._isShown = false;\n      this.isBodyOverflowing = false;\n      this.originalBodyPadding = 0;\n      this.scrollbarWidth = 0;\n      this.timerHideModal = 0;\n      this.timerRmBackDrop = 0;\n      this.isNested = false;\n      this.clickStartedInContent = false;\n      this._backdrop = clf.createLoader(_element, _viewContainerRef, _renderer);\n      this._config = modalDefaultOption || modalConfigDefaults;\n    }\n    /** allows to set modal configuration via element property */\n\n\n    set config(conf) {\n      this._config = this.getConfig(conf);\n    }\n\n    get config() {\n      return this._config;\n    }\n\n    get isShown() {\n      return this._isShown;\n    }\n\n    onClickStarted(event) {\n      this.clickStartedInContent = event.target !== this._element.nativeElement;\n    }\n\n    onClickStop(event) {\n      const clickedInBackdrop = event.target === this._element.nativeElement && !this.clickStartedInContent;\n\n      if (this.config.ignoreBackdropClick || this.config.backdrop === 'static' || !clickedInBackdrop) {\n        this.clickStartedInContent = false;\n        return;\n      }\n\n      this.dismissReason = DISMISS_REASONS.BACKRDOP;\n      this.hide(event);\n    } // todo: consider preventing default and stopping propagation\n\n\n    onEsc(event) {\n      if (!this._isShown) {\n        return;\n      }\n\n      if (event.keyCode === 27 || event.key === 'Escape') {\n        event.preventDefault();\n      }\n\n      if (this.config.keyboard) {\n        this.dismissReason = DISMISS_REASONS.ESC;\n        this.hide();\n      }\n    }\n\n    ngOnDestroy() {\n      if (this._isShown) {\n        this._isShown = false;\n        this.hideModal();\n\n        this._backdrop.dispose();\n      }\n    }\n\n    ngOnInit() {\n      this._config = this._config || this.getConfig();\n      setTimeout(() => {\n        if (this._config.show) {\n          this.show();\n        }\n      }, 0);\n    }\n    /* Public methods */\n\n    /** Allows to manually toggle modal visibility */\n\n\n    toggle() {\n      return this._isShown ? this.hide() : this.show();\n    }\n    /** Allows to manually open modal */\n\n\n    show() {\n      this.dismissReason = void 0;\n      this.onShow.emit(this);\n\n      if (this._isShown) {\n        return;\n      }\n\n      clearTimeout(this.timerHideModal);\n      clearTimeout(this.timerRmBackDrop);\n      this._isShown = true;\n      this.checkScrollbar();\n      this.setScrollbar();\n\n      if (document && document.body) {\n        if (document.body.classList.contains(CLASS_NAME.OPEN)) {\n          this.isNested = true;\n        } else {\n          this._renderer.addClass(document.body, CLASS_NAME.OPEN);\n\n          this._renderer.setStyle(document.body, 'overflow-y', 'hidden');\n        }\n      }\n\n      this.showBackdrop(() => {\n        this.showElement();\n      });\n    }\n    /** Check if we can close the modal */\n\n\n    hide(event) {\n      if (!this._isShown) {\n        return;\n      }\n\n      if (event) {\n        event.preventDefault();\n      }\n\n      if (this.config.closeInterceptor) {\n        this.config.closeInterceptor().then(() => this._hide(), () => undefined);\n        return;\n      }\n\n      this._hide();\n    }\n    /** Private methods @internal */\n\n    /**\r\n     *  Manually close modal\r\n     *  @internal\r\n     */\n\n\n    _hide() {\n      this.onHide.emit(this);\n      window.clearTimeout(this.timerHideModal);\n      window.clearTimeout(this.timerRmBackDrop);\n      this._isShown = false;\n\n      this._renderer.removeClass(this._element.nativeElement, CLASS_NAME.IN);\n\n      if (!isBs3()) {\n        this._renderer.removeClass(this._element.nativeElement, CLASS_NAME.SHOW);\n      } // this._addClassIn = false;\n\n\n      if (this._config.animated) {\n        this.timerHideModal = window.setTimeout(() => this.hideModal(), TRANSITION_DURATION);\n      } else {\n        this.hideModal();\n      }\n    }\n\n    getConfig(config) {\n      return Object.assign({}, this._config, config);\n    }\n    /**\r\n     *  Show dialog\r\n     *  @internal\r\n     */\n\n\n    showElement() {\n      // todo: replace this with component loader usage\n      if (!this._element.nativeElement.parentNode || this._element.nativeElement.parentNode.nodeType !== Node.ELEMENT_NODE) {\n        // don't move modals dom position\n        if (document && document.body) {\n          document.body.appendChild(this._element.nativeElement);\n        }\n      }\n\n      this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'false');\n\n      this._renderer.setAttribute(this._element.nativeElement, 'aria-modal', 'true');\n\n      this._renderer.setStyle(this._element.nativeElement, 'display', 'block');\n\n      this._renderer.setProperty(this._element.nativeElement, 'scrollTop', 0);\n\n      if (this._config.animated) {\n        Utils.reflow(this._element.nativeElement);\n      } // this._addClassIn = true;\n\n\n      this._renderer.addClass(this._element.nativeElement, CLASS_NAME.IN);\n\n      if (!isBs3()) {\n        this._renderer.addClass(this._element.nativeElement, CLASS_NAME.SHOW);\n      }\n\n      const transitionComplete = () => {\n        if (this._config.focus) {\n          this._element.nativeElement.focus();\n        }\n\n        this.onShown.emit(this);\n      };\n\n      if (this._config.animated) {\n        setTimeout(transitionComplete, TRANSITION_DURATION);\n      } else {\n        transitionComplete();\n      }\n    }\n    /** @internal */\n\n\n    hideModal() {\n      this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'true');\n\n      this._renderer.setStyle(this._element.nativeElement, 'display', 'none');\n\n      this.showBackdrop(() => {\n        if (!this.isNested) {\n          if (document && document.body) {\n            this._renderer.removeClass(document.body, CLASS_NAME.OPEN);\n\n            this._renderer.setStyle(document.body, 'overflow-y', '');\n          }\n\n          this.resetScrollbar();\n        }\n\n        this.resetAdjustments();\n        this.focusOtherModal();\n        this.onHidden.emit(this);\n      });\n    } // todo: original show was calling a callback when done, but we can use\n    // promise\n\n    /** @internal */\n\n\n    showBackdrop(callback) {\n      if (this._isShown && this.config.backdrop && (!this.backdrop || !this.backdrop.instance.isShown)) {\n        this.removeBackdrop();\n\n        this._backdrop.attach(ModalBackdropComponent).to('body').show({\n          isAnimated: this._config.animated\n        });\n\n        this.backdrop = this._backdrop._componentRef;\n\n        if (!callback) {\n          return;\n        }\n\n        if (!this._config.animated) {\n          callback();\n          return;\n        }\n\n        setTimeout(callback, BACKDROP_TRANSITION_DURATION);\n      } else if (!this._isShown && this.backdrop) {\n        this.backdrop.instance.isShown = false;\n\n        const callbackRemove = () => {\n          this.removeBackdrop();\n\n          if (callback) {\n            callback();\n          }\n        };\n\n        if (this.backdrop.instance.isAnimated) {\n          this.timerRmBackDrop = window.setTimeout(callbackRemove, BACKDROP_TRANSITION_DURATION);\n        } else {\n          callbackRemove();\n        }\n      } else if (callback) {\n        callback();\n      }\n    }\n    /** @internal */\n\n\n    removeBackdrop() {\n      this._backdrop.hide();\n    }\n    /** Events tricks */\n    // no need for it\n    // protected setEscapeEvent():void {\n    //   if (this._isShown && this._config.keyboard) {\n    //     $(this._element).on(Event.KEYDOWN_DISMISS, (event) => {\n    //       if (event.which === 27) {\n    //         this.hide()\n    //       }\n    //     })\n    //\n    //   } else if (!this._isShown) {\n    //     $(this._element).off(Event.KEYDOWN_DISMISS)\n    //   }\n    // }\n    // protected setResizeEvent():void {\n    // console.log(this.renderer.listenGlobal('', Event.RESIZE));\n    // if (this._isShown) {\n    //   $(window).on(Event.RESIZE, $.proxy(this._handleUpdate, this))\n    // } else {\n    //   $(window).off(Event.RESIZE)\n    // }\n    // }\n\n\n    focusOtherModal() {\n      if (this._element.nativeElement.parentElement == null) {\n        return;\n      }\n\n      const otherOpenedModals = this._element.nativeElement.parentElement.querySelectorAll('.in[bsModal]');\n\n      if (!otherOpenedModals.length) {\n        return;\n      }\n\n      otherOpenedModals[otherOpenedModals.length - 1].focus();\n    }\n    /** @internal */\n\n\n    resetAdjustments() {\n      this._renderer.setStyle(this._element.nativeElement, 'paddingLeft', '');\n\n      this._renderer.setStyle(this._element.nativeElement, 'paddingRight', '');\n    }\n    /** Scroll bar tricks */\n\n    /** @internal */\n\n\n    checkScrollbar() {\n      this.isBodyOverflowing = document.body.clientWidth < window.innerWidth;\n      this.scrollbarWidth = this.getScrollbarWidth();\n    }\n\n    setScrollbar() {\n      if (!document) {\n        return;\n      }\n\n      this.originalBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue('padding-right') || 0, 10);\n\n      if (this.isBodyOverflowing) {\n        document.body.style.paddingRight = `${this.originalBodyPadding + this.scrollbarWidth}px`;\n      }\n    }\n\n    resetScrollbar() {\n      document.body.style.paddingRight = `${this.originalBodyPadding}px`;\n    } // thx d.walsh\n\n\n    getScrollbarWidth() {\n      const scrollDiv = this._renderer.createElement('div');\n\n      this._renderer.addClass(scrollDiv, CLASS_NAME.SCROLLBAR_MEASURER);\n\n      this._renderer.appendChild(document.body, scrollDiv);\n\n      const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n\n      this._renderer.removeChild(document.body, scrollDiv);\n\n      return scrollbarWidth;\n    }\n\n  }\n\n  ModalDirective.ɵfac = function ModalDirective_Factory(t) {\n    return new (t || ModalDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.ComponentLoaderFactory), i0.ɵɵdirectiveInject(MODAL_CONFIG_DEFAULT_OVERRIDE, 8));\n  };\n\n  ModalDirective.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: ModalDirective,\n    selectors: [[\"\", \"bsModal\", \"\"]],\n    hostBindings: function ModalDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mousedown\", function ModalDirective_mousedown_HostBindingHandler($event) {\n          return ctx.onClickStarted($event);\n        })(\"mouseup\", function ModalDirective_mouseup_HostBindingHandler($event) {\n          return ctx.onClickStop($event);\n        })(\"keydown.esc\", function ModalDirective_keydown_esc_HostBindingHandler($event) {\n          return ctx.onEsc($event);\n        });\n      }\n    },\n    inputs: {\n      config: \"config\",\n      closeInterceptor: \"closeInterceptor\"\n    },\n    outputs: {\n      onShow: \"onShow\",\n      onShown: \"onShown\",\n      onHide: \"onHide\",\n      onHidden: \"onHidden\"\n    },\n    exportAs: [\"bs-modal\"]\n  });\n  return ModalDirective;\n})();","map":null,"metadata":{},"sourceType":"module"}